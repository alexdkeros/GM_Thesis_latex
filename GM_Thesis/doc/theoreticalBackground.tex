 \chapter{Theoretical Background} \label{chap:theorBack}

The present chapter contains the background knowledge required throughout the length of this thesis. Section~\ref{sec:theorBack-GM} describes the framework of the \emph{Geometric Monitoring method}. Section~\ref{sec:theorBack-MOP} presents \emph{multi-objective optimization} and  dives into the algorithms used in our implementation. Section \ref{sec:theorBack-MWMGraphs} discusses \emph{graph maximum weight matching}, and, finally, in Section~\ref{sec:theorBack-SavitzkyGolay} we explain the \emph{Savitzky-Golay filtering} used for smoothing, velocity and acceleration approximation.

%TODO gaussian process and lwpr?

\section{Geometric Monitoring of Distributed Streams} \label{sec:theorBack-GM}
 
The \emph{Geometric Monitoring} method~\cite{Sharfman2006GM} was devised as a way to monitor threshold crossings of arbitrary functions over distributed data streams, i.e. be able to determine whether an arbitrary \emph{monitoring function} $f(\cdot)$ over the data streams violated a predetermined threshold ($f(\cdot)>T$ or $f(\cdot)<T$). By mapping data streams to a feature space defined by the dimensionality of each data stream update and monitoring the convex hull surrounding the value of the monitoring function, Sharfman et al. were able to decompose the monitoring task into local constraints and apply distributed threshold monitoring, while reducing the communication costs required by central data processing.

In the current section a detailed presentation of this method is taking place. In Subsection~\ref{subsec:theorBack-GM-sysArch} two system architectures are shown, a decentralized scenario and a centralized one, where Geometric Monitoring can be applied. Subsection~\ref{subsec:theorBack-GM-compMod} explains the computational model, followed by the method's geometric interpretation in Subsection~\ref{subsec:theorBack-GM-geomInt}. Finally, in Subsection~\ref{subsec:theorBack-GM-protocol} the protocol implementing the Geometric Monitoring method is described.


\subsection{System Architecture} \label{subsec:theorBack-GM-sysArch}

In~\cite{Sharfman2006GM} two different scenarios of Geometric Monitoring corresponding to different network topologies are examined. The \emph{decentralized scenario} refers to a topology where nodes are allowed to communicate with each other and a central node is absent. The \emph{centralized scenario} models a star network topology, where a coordinator node communicating with all other nodes is existent.

\subsubsection{Decentralized Scenario} \label{subsubsec:theorBack-GM-decentralized}

The topology examined is that of a partially or fully connected mesh network where a coordinator node is absent and nodes are allowed to broadcast to the network or communicate with each other according to the links existent between them. Data stream update vectors arrive continuously at each of the monitoring nodes and nodes must always be synchronized, i.e. all nodes must be aware of the monitoring task's state at all times. An example is depicted in Figure~\ref{fig:decentralized}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% decentralized figure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
\centering
\includegraphics{img/decentralized.tex}
\caption{Network topology example of the decentralized scenario. Dashed lines represent data streams and half arrows represent message exchanges.} 
\label{fig:decentralized}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Centralized Scenario}\label{subsubsec:theorBack-GM-centralized}

The \emph{centralized}, or \emph{coordinator-based} scenario is built upon a star network topology, where all monitoring nodes communicate with a central node, the \emph{coordinator node}. Nodes receive data stream update vectors continuously, and must communicate their state information to the coordinator node when needed. The coordinator receives data stream updates as well, which can be modelled by an additional monitoring node responsible for the cooridinator node's data stream. Communication between monitoring nodes is not allowed, thus, only the communicator can, and must, be aware of the state of the monitoring task at all times. An example is depicted in Figure~\ref{fig:centralized}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% centralized figure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
\centering
\includegraphics{img/centralized.tex}
\caption{Network topology example of the centralized scenario.The bold node represents the coordinator node. Dashed lines represent data streams and half arrows represent message exchanges.} 
\label{fig:centralized}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Computational Model} \label{subsec:theorBack-GM-compMod}

The main goal of the Geometric Monitoring method is to efficiently detect threshold crossings of an arbitrary function over distributed data streams. This is realized via vector projections of the data streams and convex local constraint assignments regarding said vectors at the nodes.

Let $f:\mathbb{R}^d \to \mathbb{R}$ be an arbitrary function, the \emph{monitoring function}, whose value over the data streams needs to be monitored, so that if $f(\cdot)>T$ or $f(\cdot)<T$ an alarm is raised. For linear functions this problem is trivial, so that by letting, for example, $x_1$ and $x_2$ be data stream values at different nodes and requiring $f(\frac{x_1+x_2}{2})>10$ to be monitored, it holds that $f(\frac{x_1+x_2}{2})=\frac{f(x_1)+f(x_2)}{2}$, and the problem can be decomposed to local constraints $f(x_i)<10, i=1,2$ at both nodes, i.e. a node remains silent until it violates its local constraint. Consider now the case of a non-linear function. By knowing the value of the function at the nodes nothing can be deduced about the function's value over the average of the monitoring streams and where it is positioned with respect to the threshold. Let $f(x)=10x-x^2$, $x_1=0$ and $x_2=9$. Even thought $f(x_1)=0<10$ and $f(x_2)=9<10$, their average violates the specified threshold, $f(\frac{x_1+x_2}{2})=f(4.5)=24.75>10$. 

In order to be able to effectively track non-linear functions, in the likes of the aforementioned example, a mapping of the streams to a vector space is taking place. Let $P=\{p_1, ..., p_n\}$ be the monitoring node set with weights $w_1, ..., w_n$, which can be either static or time varying. Their respective data streams $S=\{s_1, ..., s_n\}$ are represented by $\vec{v_1}(t), ..., \vec{v_n}(t)$, the $d$-dimensional \emph{local statistics vectors} of the nodes at time $t$. The \emph{global statistics vector} at time $t$ is the weighted average of the local statistics vectors, as such:
\begin{equation}
\vec{v}(t)=\frac{\sum_{i=1}^n{w_i\vec{v_i}(t)}}{\sum_{i=1}^n{w_i}}
\label{form:globalStatsVector}
\end{equation}

Infrequent communication between monitoring nodes, in the decentralized scenario, or between monitoring nodes and the coordinator, in the coordinator-based scheme, dictates the need to keep track of the value of the global statistics vector at the time the last global communication occurred, thus forming the \emph{estimate vector}:
\begin{equation}
\vec{e}(t)=\frac{\sum_{i=1}^n {w_i \vec{v_i}'}}{\sum_{i=1}^n {w_i}}
\label{form:estimateVector}
\end{equation}
,where $\vec{v_i}'$ is the last communicated statistics vector of node $p_i$.

At the monitoring nodes the difference between the current local statistics vector and the last communicated statistics vector is denoted by $\Delta \vec{v_i}(t)=\vec{v_i}(t)-\vec{v_i}', i=1,...,n$. The \emph{drift vector} $\vec{u_i}(t), i=1,...,n$, also maintained at the monitoring nodes, represents the deviation of each node's data stream from the estimate vector and is defined differently in the two scenarios:
\begin{itemize}
\item In the \textbf{decentralized} setting the drift vector is regarded as the displacement of the local statistics vector from the estimate vector:
\begin{equation}
\vec{u_i}(t)=\vec{e}(t)+\Delta \vec{v_i}(t)
\label{form:decentralizedDrift}
\end{equation}
\item In the \textbf{centralized} setting the monitoring nodes forward their state to the coordinator node, who has a global overview of the monitoring task at hand. This property allows the coordinator to counteract the effects a specific stream has on the partially observed monitoring task with an other, ``opposite'', stream belonging to a different monitoring node. This is taken care by the \emph{balancing process} initiated every time a local violation occurs, which is responsible for computing and communicating the \emph{slack vector} $\vec{\delta_i}$ to the nodes that contributed to the process, thus providing them with the necessary disposition of their drift vectors, as such:
\begin{equation}
\vec{u_i}(t)=\vec{e}(t)+\Delta \vec{v_i}(t)+\frac{\vec{\delta_i}}{w_i}
\label{form:centralizedDrift}
\end{equation} 
\end{itemize}

\subsubsection{Balancing Process} \label{subsubsec:theorBack-GM-balancingProc}

The balancing process taking place in the \textbf{centralized scenario} is initiated by the coordinator node every time a threshold violation occurs, with the objective of resolving a possibly false alarm with minimal communication overhead. This task is executed by collecting a subset of monitoring nodes' data, the \emph{balancing set} $P'$, until the average of their drift vectors, the \emph{balancing vector}, does not cause a threshold crossing. The balancing vector is formulated as follows:
\begin{equation}
\vec{b}=\frac{ \sum_{p_i \in P'} {w_i\vec{u_i}(t)} }{ \sum_{p_i \in P'} {w_i} }
\label{form:balancingVector}
\end{equation}

After a successful balancing process has come to an end, $\Delta\vec{\delta_i}$ slack vector adjustments for all participants in the balancing set $P'$ are computed and communicated to their respective sites, so that local drift vectors can be readjusted to reflect the balancing operation by computing $\vec{\delta_i}=\vec{\delta_i}'+\Delta\vec{\delta_i}$, where $\vec{\delta_i}'$ the previous slack vector (Equation~\ref{form:centralizedDrift}). These adjustments are calculated as follows:
\begin{equation}
\Delta\vec{\delta_i}=w_i\vec{b}-w_i\vec{u_i}(t)\ \forall\ p_i \in P'
\end{equation}
, where $\sum_{p_i \in P'} \Delta \vec{\delta_i}= \vec{0}$. Once the slack vector adjustments have been communicated to the respective monitoring nodes participating in $P'$, their drift vectors are essentially set to the value of the newly computed balancing vector.

In case the balancing process proves unsuccessful all monitoring nodes are contained in the balancing set $P'$ and a new estimate vector is computed with the data cumulated at the coordinator node. Subsequently, all drift vectors and slack vectors are set to $\vec{0}$.

\subsection{Geometric Interpretation} \label{subsec:theorBack-GM-geomInt}

The estimate vector, being the product of the system's previous global synchronization, is known to all monitoring nodes and denotes the last known position of the global statistics vector. That being said, the estimate vector is considered valid if it resides on the same side of the threshold as the unknown global statistics vector.
In order to estimate the current position of the global statistics vector, since a mere observation of the monitoring function's value at each stream provides no information about its current location (as described in Section~\ref{subsec:theorBack-GM-compMod}), it is vital that the task is decomposed into local constraints that will guarantee the timely detection of a violation of the estimate's vector validity.

The \emph{convexity property} of the drift vectors, along with Theorem~\ref{theorem:convexHull}~\cite{Sharfman2006GM}, are sufficient in provide a framework for decomposing the monitoring task into local constraints at the nodes. Both the convexity property and the relevant theorem are repeated below for completeness.
	
The convexity property dictates that the weighted average of the drift vectors equal the global statistics vector, as such:
\begin{equation}
\vec{v}(t)=\frac{\sum_{i=1}^n {w_i\vec{u_i}(t)}}{\sum_{i=1}^n {w_i}}
\label{form:convexityProperty}
\end{equation}
The geometric interpretation of the property guarantees that the global statistics vector $\vec{v}$ is always contained in the convex hull defined by the drift vectors $\vec{u_i}, i=1,...,n$.


\begin{theorem}[Sharfman et al.~\cite{Sharfman2006GM}]\label{theorem:convexHull}
Let $\vec{x}, \vec{y_1}, ..., \vec{y_n} \in \mathbb{R}^d$ be a set of vectors in $\mathbb{R}^d$. Let $Conv(\vec{x}, \vec{y_1}, ..., \vec{y_n})$ be the convex hull of $\vec{x}, \vec{y_1}, ..., \vec{y_n}$. Let $B(\vec{x}, \vec{y_i})$ be a ball centered at $\frac{\vec{x}+\vec{y_i}}{2}$ and with radius of $\norm{\frac{\vec{x}+\vec{y_i}}{2}}_2$ i.e., $B(\vec{x}, \vec{y_i})=\{\vec{z}\ |\ \norm{\vec{z}-\frac{\vec{x}+\vec{y_i}}{2}}_2 \leq \norm{\frac{\vec{x}+\vec{y_i}}{2}}_2 \}$, then $Conv(vec{x}, \vec{y_1}, ..., \vec{y_n}) \subset B(\vec{x}, \vec{y_i})$.
\end{theorem}

Essentially, Theorem~\ref{theorem:convexHull} states that $n$ $d$-dimensional spheres defined by $n+1$ vectors can effectively bound the convex hull defined by said vectors, as such: $Conv(\vec{x}, \vec{y_1}, \vec{y_2}, ..., \vec{y_n}) \subset  \cup B(\vec{x}, \vec{y_i}), i=1,...,n$, which finds direct application to the distributed monitoring task if $\vec{x}=\vec{e}$ and $\vec{y_i}=\vec{u_i}, i=1,...,n$. An example is depicted in Figure~\ref{fig:convexHull}
.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% convex hull figure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
\centering
\includegraphics[scale=0.7, trim=0 0 4.2cm 0]{img/convex_hull.tex}
\caption{Example of a convex hull (light gray) defined by the drift vectors $\vec{u_i}, i=1,2,3,4,5$. The hull is bounded by the spheres created from the estimate vector $\vec{e}$ and the drift vectors $\vec{u_i}, i=1,2,3,4,5$. The global statistics vector $\vec{v}$ is guaranteed to be contained in the convex hull of the drift vectors.} 
\label{fig:convexHull}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Local Constraints} \label{subsubsec:theorBack-GM-localConstraints}

The decomposition of the threshold monitoring task to local constraints at the nodes, in which each node monitors its respective bounding sphere $B(\vec{e}, \vec{u_i}), i=1,...n$ for a possible threshold violation, induces a coloring upon the spheres. Let $V=\{\vec{x} | f(\vec{x}>T)\}$ be the set of vectors said to be \emph{green}, and $\overline{V}=\{\vec{y} | f(\vec{y}<T)\}$ the \emph{red} set of vectors, then the local constraint monitoring at the nodes is essentially a process of monitoring the monochromaticity of a node's bounding sphere $B(\vec{e}, \vec{u_i})$ i.e., all vectors in the bounding ball are of the same color. As long as this monochromaticity is upheld for the whole of the node set, the convex hull defined by the drift vectors is monochromatic and, by the convexity property, the global statistics vector has not crossed the threshold. In case a single node signals a threshold crossing a \emph{local violation} has occurred. If the local violation coincides with a threshold crossing of the global statistics vector, then a \emph{global violation} has occurred.

\subsection{Protocol} \label{subsec:theorBack-GM-protocol}

Two variants of a network's topological structure have been proposed for application of the Geometric Monitoring method, a decentralized scenario and a centralized, coordinator-based one (Section~\ref{subsec:theorBack-GM-sysArch}). The following paragraphs present the algorithms for each of these systems.

\subsubsection{Decentralized Algorithm} \label{subsubsec:theorBack-GM-decentralizedAlgo}

The decentralized scenario of the geometric monitoring method, summarized in Algorithm~\ref{algo:decentralized}, operates on the mesh network described in Section~\ref{subsubsec:theorBack-GM-decentralized}. Each node $p_i$ keeps track of its drift vector $\vec{v_i}(t)$ and the previously communicated statistics vectors $\vec{v_j}'$ from all other nodes $p_j$, from which the estimate vector is locally computed. At the occurence of a local violation the violating node initiates a global system synchronization by broadcasting its local statistics vector along with its unique identifier, from which the estimate vector is globally updated so that monochromaticity checks are valid.\\ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% decentralized algo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[H]
\setstretch{1.30}


\Begin{
	\ForEach(\tcc*[f]{Node initialization}){node $p_i$}{
		Broadcast $\vec{v_i}(0)$\;
		$\vec{v_i}'=\vec{v_i}(0)$\;
		Wait messages from all other nodes\;
		\If{messages from all vectors received}{
			$\vec{e}(t)=\frac{\sum_{i=1}^n {w_i \vec{v_i}'}}{\sum_{i=1}^n {w_i}}$\;
		}
	}

	\ForEach(\tcc*[f]{Main monitoring task}){node $p_i$}{
		\ForEach{new $s_i$ stream update $\vec{v_i}(t)$}{
			Recalculate $\vec{u_i}(t)=\vec{e}(t)+\Delta \vec{v_i}(t)$\;
			\If{$B(\vec{e},\vec{u_i}(t))$ is \emph{not} monochromatic}{
				Broadcast message $<i,\vec{v_i}(t)>$\;
				Set $\vec{v_i}'=\vec{v_i}(t)$\;
			}
		

			\If{new message $<j,\vec{v_j}(t)>$ received}{
				Set $\vec{v_j}'=\vec{v_j}(t)$\;
				Recalculate $\vec{e}(t)=\frac{\sum_{i=1}^n {w_i \vec{v_i}'}}{\sum_{i=1}^n {w_i}}$\;
				\If{$B(\vec{e},\vec{u_i}(t))$ is \emph{not} monochromatic}{
					Broadcast message $<i,\vec{v_i}(t)>$\;
					Set $\vec{v_i}'=\vec{v_i}(t)$\;
				}
			}
		}

	}
}
\caption{Decentralized algorithm \label{algo:decentralized}} 
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{Centralized Algorithm} \label{subsubsec:theorBack-GM-centralizedAlgo}

The centralized, coordinator-based geometric monitoring operation is summarized in Algorithms~\ref{algo:centralizedMonitoringNode},  and~\ref{algo:centralizedCoordinatorNode}, where the execution sequence of the monitoring nodes and the execution sequence of the coordinator node are described, respectively. The topology is that of a star network, where nodes are allowed to communicate exclusively with the coordinator node, as described in Section~\ref{subsubsec:theorBack-GM-centralized}. The coordinator node is responsible for answering queries about the monitoring status i.e., has absolute knowledge about threshold violations, and handles the balancing process (Section~\ref{subsubsec:theorBack-GM-balancingProc}). Local streams are tracked by the monitoring nodes on the basis of the last communicated estimate vector, and must inform the coordinator for any local threshold violation. The coordinator node can also monitor is respective data stream without any change in the described framework.\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% centralized monitoring node algo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[H]
\setstretch{1.30}
\Begin{
	\ForEach(\tcc*[f]{Node initialization}){node $p_i$}{
		Send $<INIT,\vec{v_i}(0)>$ message to coordinator\;
		$\vec{v_i}'=\vec{v_i}(0)$\;
		$\vec{\delta_i}=\vec{0}$\;
		Wait message from coordinator\;
		\If{$<NEW\textnormal{-}EST, \vec{e}>$ message received}{
			Set $\vec{e}(t)=\vec{e}$\;
		}
	}

	\ForEach(\tcc*[f]{Main monitoring task}){node $p_i$}{
		\ForEach{new $s_i$ stream update $\vec{v_i}(t)$}{
			Recalculate $\vec{u_i}(t)=\vec{e}(t)+\Delta \vec{v_i}(t)+\frac{\vec{\delta_i}}{w_i}$\;
			\If{$B(\vec{e},\vec{u_i}(t))$ is \emph{not} monochromatic}{
				Send $<REP,\vec{v_i}(t),\vec{u_i}(t)>$ message to coordinator\;
				Wait for $<NEW\textnormal{-}EST,\cdot>$ or $<ADJ\textnormal{-}SLK,\cdot>$ message from coordinator\;
			}
		
		
			\If{new message $<REQ>$ received}{
				Send $<REP,\vec{v_i}(t),\vec{u_i}(t)>$ message to coordinator\;
				Wait for $<NEW\textnormal{-}EST,\cdot>$ or $<ADJ\textnormal{-}SLK,\cdot>$ message from coordinator\;

			}

			\If{new $<NEW\textnormal{-}EST, \vec{e}>$ message received}{
				Set $\vec{e}(t)=\vec{e}$\;
				$\vec{v_i}'=\vec{v_i}(t)$\;
				$\vec{\delta_i}=\vec{0}$\;
			} 

			\If{new $<ADJ\textnormal{-}SLK, \Delta\vec{\delta_i}>$ message received}{
				$\vec{\delta_i}=\vec{\delta_i}+\Delta\vec{\delta_i}$\;
			}

		}

	}
}
\caption{Centralized algorithm's monitoring node operation \label{algo:centralizedMonitoringNode}} 
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% centralized coordinator node algo %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
\setstretch{1.30}

\SetKwFunction{Balance}{Balance}
\SetKwProg{Fn}{Function}{}{end}

\Begin{
	
	Wait for $<INIT, \cdot>$ messages from all monitoring nodes\tcc*[r]{Initialization}
	$\vec{e}(0)=\frac{\sum_{i=1}^n {w_i \vec{v_i}(0)}}{\sum_{i=1}^n {w_i}}$\;

	\If(\tcc*[f]{Monitoring operation}){new $<REP,\vec{v_i}(t),\vec{u_i}(t)>$ message received}{
		$P'=P' \cup \{<i,\vec{v_i}(t),\vec{u_i}(t)>\}$\;
		\Balance{$P'$}\;
	}
}

\Fn(\tcc*[f]{Balancing Process}){\Balance{$P'$}}{
	$\vec{b}=\frac{ \sum_{p_i \in P'} {w_i\vec{u_i}(t)} }{ \sum_{p_i \in P'} {w_i} }$\;
	\uIf{$B(\vec{e}, \vec{b})$ is \emph{not} monochromatic}{
		\uIf{$P-P'\neq \emptyset$}{
			Send $<REQ>$ message to random node in $P-P'$ set\;
		}
		\Else{
			$\vec{e}(t)=\frac{\sum_{i=1}^n {w_i \vec{v_i}(t)}}{\sum_{i=1}^n {w_i}}$\;
			Send $<NEW\textnormal{-}EST, \vec{e}(t)>$ message to all nodes\;
			\Return \;
		}
	}
	\Else{
		\ForEach{$p_i \in P'$}{
			$\Delta\vec{\delta_i}=w_i\vec{b}-w_i\vec{u_i}(t)$\;
			Send $<ADJ\textnormal{-}SLK, \Delta\vec{\delta_i}>$ message to node $p_i$\;
			\Return \;
		}
	}

}
\caption{Centralized algorithm's coordinator node operation\label{algo:centralizedCoordinatorNode}} 
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Multiobjective Optimization} \label{sec:theorBack-MOP}

what is mop\\
use examples\\
kinds:\\
	a.numerical\\
	b.evolutionary
\subsection{SLSQP} \label{subsec:theorBack-SLSQP}

\subsection{Sohr's algorithm a.k.a. ralg} \label{subsec:theorBack-CONMIN}

algorithm description

\section{Savitzky-Golay Filtering} \label{sec:theorBack-SavitzkyGolay}

filtering generals\\
examples of uses of filters\\
filters:\\
	Kalman\\
		+,-
	Moving Average\\
		+,-
	Savitzky-Golay a.k.a. ???
		+,-

algorithm description

\section{Maximum Weight Matching in Graphs} \label{sec:theorBack-MWMGraphs}

general graph theory (introductory)

what is max weight matching

algorithm description
