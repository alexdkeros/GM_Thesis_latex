\chapter{Implementation} \label{chap:impl}

This chapter provides a detailed description of the implemented system. In Section~\ref{sec:impl-GM}, the Geometric Monitoring method implementation is described, along with the necessary simplyfing assumptions to aid experimentation. Following that, in Section~\ref{sec:impl-distNodeMatch} an algorithm for node matching is proposed, inspired by the violation recovery method found in~\cite{Keren2014GMHetStreams}. In Section~\ref{sec:impl-heuristic}, the heuristic based balancing method for local violation resolution is presented, along with the necessary data stream tracking scheme. Finally, the main implementation challenges are discussed.

\section{Geometric Monitoring Implementation} \label{sec:impl-GM}

The initial Geometric Monitoring method~\cite{Sharfman2006GM}, which is described in detail in Section~\ref{sec:theorBack-GM}, provides two algorithms for threshold monitoring of distributed data streams. These algorithms operate on different network structures and implement a somewhat different handling of threshold violations.

The decentralized algorithm operates on a coordinator-less enviroment, where nodes are allowed to communicate with each other, whereas the coordinator-based algorithm has a Star network topology, where the coordinator node is the central node (the \emph{hub}) and the Monitoring nodes recide on the edges of the network.
The algorithm operating on the decentralized setting does not provide a balancing process for local violation resolution. On the other hand, the coordinator based algorithm implements a violation resolution operation every time a local violation occurs, which aims to minimize the communication overhead induced by false violation reports. 

Our focus is centered towards a simplified \textbf{coordinator-based algorithm} (Algorithm~\ref{algo:GM-coordBased}), described in Section~\ref{sec:theorBack-GM}, as it provides a framework for the heuristic balancing process, as well as the node matching operation presented in detail in Sections~\ref{sec:impl-heuristic} and~\ref{sec:impl-distNodeMatch} respectively.

To aid method formulation and experimentation, the following simplifying assumptions have been made regarding the coordinator-based algorithm:
\begin{itemize}
\item Communication between nodes is considered instantaneous. There is no delay when passing messages through the network. The problem of message handling in a real-world Geometric Monitoring method implementation, where message delays are induced by the underlying network, has been studied in detail in~\cite{Babis2013SimulatorStreams}.

\item Communication between nodes is considered loss-less and reliable. In case network reliability can not be guaranteed appropriate methods should be considered.

\item The system operates in an iterative fashion, as described in Algorithm~\ref{algo:singleHandlingNetwork}. This simplification of the real-time distributed monitoring process to an iterative process provides a more manageable setting for experimentation without distorting the results of the proposed methods, which can be applied directly to the original real-time distributed setting.

\item The system pauses at each violation, until the violation is resolved. During violation resolution Monitoring nodes do not receive updates from their respective data streams.

\item The Coordinator node does not participate in the monitoring operation. The Coordinator node does not receive updates from a data stream, it only receives messages from the Monitoring nodes in case of threshold violation.

\end{itemize}

\begin{algorithm}[H]
\setstretch{1.30}
\SetKwData{Node}{node}\SetKwData{GlobalViolation}{Global\_Violation}\SetKwData{MonitoringNodes}{Monitoring\_Nodes}\SetKwData{Coord}{coordinator}\SetKwData{LocalViolation}{Local\_Violation}

\SetKwFunction{DataUpdate}{data\_update}\SetKwFunction{ComputeDrift}{compute\_drift\_vector}\SetKwFunction{Report}{report}\SetKwFunction{Balance}{balance}\SetKwFunction{CheckViolation}{check\_for\_violation}

\SetAlgoLined
\Begin{
 initialization\;
 	\Repeat{\GlobalViolation}{
		\ForAll{\MonitoringNodes}{
			\Node.\DataUpdate{}\;
			\Node.\ComputeDrift{}\;
		}
		\ForAll{\MonitoringNodes}{
			\Node.\CheckViolation{}\;
			\If{\LocalViolation}{
				\Node.\Report{}\;
				\Coord.\Balance{}\;
			}
		}
	}
}
 \caption{Iterative network operation \label{algo:singleHandlingNetwork}} 
\end{algorithm}

\section{Distance Based Node Matching} \label{sec:impl-distNodeMatch}

The balancing method of the coordinator-based algorithm, as described in Section~\ref{sec:theorBack-GM}~\cite{Sharfman2006GM, Sharfman2008ShapeSensGM}, aims at resolving local violations that do not result in a global violation (\emph{false alarms}) by balancing the violating node's drift vector with the respective vectors of randomly chosen nodes. Consider the violating node $n_i$ with weight $w_i=1$, so that the bounding ball $B(\vec{e}(t), \vec{u_i}(t))$ is not monochromatic, and the randomly requested node $n_j$ with weight $w_j=1$, so that the newly formed bounding ball is $B(\vec{e}(t), \frac{\vec{u_i}(t)+\vec{u_j}(t)}{2})$, where $\vec{e}(t)$ the estimate vector at time $t$ and $\vec{u_i}(t)$, $\vec{u_j}(t)$ the drift vectors of nodes $n_i$, $n_j$ at time $t$, respectively. If the resulting bounding ball is monochromatic the violation is resolved, otherwise another node is randomly requested for balancing.

As observed in~\cite{Keren2014GMHetStreams}, the original balancing method's node choosing scheme can be inefficient, so a more efficient and deterministic approach should be adopted. Optimal pairing of nodes and the construction of a hierarchical structure (Figure~\ref{fig:nodePairHierarchy}) reduces the communication overhead of false alarms, with the vast majority of violation resolutions requiring only the assigned node pair to be successful. The criterion by which nodes are paired attempts to maximize the probability of a successful balance by maximizing \textit{``the percentage of pairs of data vectors from both nodes whose sum is in the Minkowski sum of the nodes' safe-zones''}~\cite{Keren2014GMHetStreams}, or, in this case, whose resulting bounding ball is monochromatic.

Here, the same node pairing scheme is followed, but with a different, distance based, criterion for grouping nodes into disjoint pairs and creating the hierarchical structure depicted in Figure~\ref{fig:nodePairHierarchy}. The method proceeds as follows:
\begin{enumerate}
\item Monitoring nodes are visualized as the nodes of a complete graph $G=(V,E)$, where $V=\{n_1, n_2, ... , n_k\}$ vertex set consists of the initial Monitoring nodes (\emph{``Type-1 nodes''}) and $E=\{(n_i, n_j)\ \forall i,j \in \{1, ..., k\}, i \neq j\}$ edge set contains an edge for every pair of vertices.
\item Weights are assigned to all edges $E$. The weight of each edge is defined as the cumulative distance of the value of the monitoring function on the mean of each pair of data vectors from the value of the monitoring function on the \emph{global} mean of all Monitoring nodes' data vectors, plus the cumulative distance of each pair of data vectors:
\begin{equation}
w_{i,j}=
\sum_{t=0}^{t_{end}}{[(f(\vec{v}_{global}(t))-f(\frac{\vec{v_i}(t)+\vec{v_j}(t)}{2}))+(|\vec{v_i}(t)-\vec{v_j}(t)|)]}
\label{form:distanceMatchingWeights}
\end{equation}
, where $v_i(t)$ the data update of node $n_i$ at time $t$, $\vec{v}_{global}(t)$ the global mean of all Monitoring nodes at time $t$ and $f(\cdot)$ the monitoring function.

\item Maximum weighted matching is performed on the resulting graph, so that nodes are partitioned into disjoined sets $M_i$, $|M_i|=2\ \forall i \in \{1, ..., \frac{k}{2}\}$.
\item Each set $M_i, i \in \{1, ..., \frac{k}{2}\}$ is considered a single node, so that a new complete graph $G'=(V', E')$ is created, where $V'=\{M_1, ..., M_{\frac{k}{2}}\}$ (\emph{``Type-2 nodes''}) the new vertex set and $E'=\{(M_i, M_j)\ \forall i,j \in \{1, ..., \frac{k}{2}\}\}$ the new edge set. Weights are assigned to the new edges and the process repeats until the resulting graph contains only a single vertex (\emph{``Type-k node''}), which incorporates all the initial Monitoring nodes. 
\end{enumerate} 

\begin{figure}
\centering
\includegraphics[trim=0 9cm 0 0]{img/NodeMatchingHierarchy.tex}
\caption{Hierarchical pairing scheme example  for node set $\{n_1, n_2, n_3, n_4, n_5, n_6, n_7, n_8\}$.} 
\label{fig:nodePairHierarchy}
\end{figure}


our method:\\
describe in detail, mentioning that its the same process as in deligiannakis\\
*image of disjoint pairs\\
mention our criterion for matching\\
*image of matching results on classic balancing method\\
emphasize global statistics vector following, emphasize matching of nodes on the extremes (i.e. higher velocity one with lower velocity one)

algorithm\\

\section{Heuristic Balancing} \label{sec:impl-heuristic}

balancing process geometric interpretation\\
*image

balancing process algorithm

\subsection{Smoothing, Velocity and Acceleration Estimation via Savitzky-Golay} \label{subsec:impl-heuristic-vel}

S-G implementation\\
*image

\section{Implementation Challenges} \label{sec:impl-implChallenges}

training data

complexity of optimization (i.e. optimal point location)

complexity of optimization (i.e. node matching)